var dataP = characters.length,
	dataB = scoreArray(60), //shows the top 100 similar patients
	mortData = cropArray(60, died);
	//dataB = binScoreArray(100);
//DM:
var mouseIsDown = false,
	minRange = Number.MAX_VALUE;
	maxRange = Number.MIN_VALUE;
	
var tBarW = 200,
    tBarH = 600,
    tx = d3.scale.linear().domain([0, 1]).range([0, tBarW]),
    ty = d3.scale.ordinal().domain(d3.range(dataB.length)).rangeBands([0, tBarH], .2);
	size = 600;
	padding = 20,
	barMargin = 15;

var tSelectionBar = d3.select("#selectionBar")
	.append("svg:svg")
	    .attr("width", tBarW + 40) //add padding for axis labels
	    .attr("height", tBarH + 20)
	  .append("svg:g")
	    .attr("transform", "translate(20,0)");
	tSelectionBar.append("svg:text")
	  .attr("class", "title")
	  .attr("y", 10 )
	  //.attr("dy", ".71em")
	  //.attr("transform", function(d) {return "translate(" + ((d % numPerRow) * (mainPanelW + margin)) + "," + (Math.floor(d/numPerRow) * (mainPanelH + margin) + textOffset) + ")";})
	  .text("Patient Selection Bar");

var tbars = tSelectionBar.selectAll("g.bar")
    .data(dataB)
  .enter().append("svg:g");
    //.attr("class", "oneBar")
    //.attr("transform", function(d, i) { return "translate(0," + ty(i) + ")"; });

tbars.append("svg:rect")
    .attr("x", 0)
    .attr("y", function(d,i) { return ty(i)+barMargin; })
    .attr("width", function(d,i) {return tx(d.score);})
    .attr("height", ty.rangeBand())
    .style("fill", function(d,i){ 
		if(mortData[d.index]==0)
			return "steelblue";
		else
		 	return "lightgreen";
		})
	.attr("pointer-events", "all")
	.attr("visibility", function(d, i) {return d.index == 0 ? "hidden" : "visible";})     
	.on("mousedown", mousedown)
	
	.on("mouseout", function(d,i) {
		if(!mouseIsDown)
			d3.select(this).style("fill", function(d,i){ 
				//DM: 
				//if(mortData[dataB.indexOf(d)]==0)
				if(mortData[d.index]==0)
					if(d.index <= maxRange && d.index >= minRange)
						return "firebrick"
					else
						return "steelblue";
				else
					if(d.index <= maxRange && d.index >= minRange)
						return "pink";
					else
				 		return "lightgreen";
				});
		//DM: didn't see this function doing anything
		//highlight(-1);
	})
	
	
	.on("mouseover", function(d,i) {
		d3.select(this).style("fill", "blue");
		if(mouseIsDown){
			if(maxRange < d.index)
				maxRange = d.index;
			if(minRange > d.index)
				minRange = d.index;
		}
		//DM: this function wasn't doing anything...
		//highlight(i);
	});
	
	
tbars.append("svg:text")
    .attr("x", tx)
	.attr("y",function(d,i) { return ty(i)+20; })
	.attr("x", function(d, i) {return d.score * tBarW;})
    .attr("dy", ".35em")
    .attr("fill", "white")
    .attr("text-anchor", "end")
	.text(function(d) {return d.score.toFixed(2);});

d3.select(window)
	.on("mousemove", mousemove)
	.on("mouseup", mouseup);
	
var rect, x0, x1, count;

function mousedown() {			
	//DM: update our selection state
	mouseIsDown = true;
	minRange = Number.MAX_VALUE;
	maxRange = Number.MIN_VALUE;
	
    x0 = d3.svg.mouse(this);
	//DM: Maybe supposed to count how many bars we've highlighted so far?
    count = 0;

	//DM: update selection range
	minRange = d3.select(this).node().__data__.index;
	maxRange = d3.select(this).node().__data__.index;
    		
    rect = d3.select(this.parentNode.parentNode)
    	.append("svg:rect")
       	.style("fill", "#999")
       	.style("fill-opacity", .5);

    d3.event.preventDefault();
  }

var tracker = [];

function mousemove() {
	if (!rect) return;
	x1 = d3.svg.mouse(rect.node());
	
	var minx = Math.min(x0[0], x1[0]),
		maxx = Math.max(x0[0], x1[0]),
		miny = Math.min(x0[1], x1[1]),
		maxy = Math.max(x0[1], x1[1]);
	
	rect
		.attr("x", minx - .5)
		.attr("y", miny - .5)
		.attr("width", maxx - minx + 1)
		.attr("height", maxy - miny + 1);
		
	var v = rect.node().__data__;
	tracker.push(v);
	
	count = 0;
}

function mouseup() {
	
	//DM: reset our mousedown state
	mouseIsDown = false;
	
	if (!rect) return;
	rect.remove();
	rect = null;
				
	//DM: wasn't sure what count was doing
	//if(!count) 
	tSelectionBar.selectAll("rect")
		.style("fill", function(d,i){ 
			//console.log(d);
		//DM:
		//if(mortData[dataB.indexOf(d)]==0)
		if(mortData[d.index]==0)
			if(d.index <= maxRange && d.index >= minRange)
				return "firebrick"
			else
				return "steelblue";
		else
			if(d.index <= maxRange && d.index >= minRange)
				return "pink";
			else
		 		return "lightgreen";
		});
		
	//DM: update data selection
	subsetSelection(minRange, maxRange);
	//DM: redraw our lines appropriately
	if(aggregated)
		redraw_envelopes();
	else
		redraw_lines();
	//redraw our subpanels
	redraw_sub_panels();
}

function 